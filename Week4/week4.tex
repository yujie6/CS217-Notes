\documentclass[12pt,a4]{article}

\newcommand{\handoutdate}{Friday, 2020-04-17}
\newcommand{\firstduedate}{Friday, 2019-04-24}
\newcommand{\finalduedate}{Tuesday, 2020-05-01}


\input{preamble}

\setcounter{section}{3}

\section{Bottleneck Paths}

Let $G=(V,E)$ be a directed graph with an edge capacity function $c: E \rightarrow \R^+$. For a path
$p = u_0 u_1 \dots u_t$ define its {\em capacity} to be
\begin{align}
   c(p) := \min_{1 \leq i \leq t} c( \{u_{i-1}, u_i\}) \ .
\end{align}

\begin{quotation}
    \textbf{Maximum Capacity Path Problem (MCP).} Given a directed graph $G = (V,E)$, an edge capacity function
    $c: E \rightarrow \R^+$, and two vertices $s, t \in V$, compute the path $p^*$ maximizing $c(p)$. We
    denote by $p^*$ the optimal path and by $c^* := c(p^*)$ its cost. 
\end{quotation}



\begin{exercise}
   Suppose the edges $e_1,\dots,e_m$ are sorted by their cost. Show how to solve MCP in time $O(n+m)$.
\end{exercise}

\begin{proof}
Design a algorithm following Pseudocode shows(Suppose the edges are sorted decreased, See in Algorithm 1):

And then we think about the correctness and complexity.

The algorithm means we can enum the answer. When we find a edge between the point visited and not visited, we can go through all the edges which's costs is higher than this edge. If now s is connected to t, means this edge is the largest edge while going through all edges higher than it from $s$ to $t$. That fits the answer we want.

Now, let's think about the complexity. For every node, it may be in queue at least once. And for every edge, it may be in $G'$ and used in bfs at least once. So the time complexity is $O(n+m)$.
\begin{algorithm}[H]
\caption{Solve MCP in time $\Theta(n+m)$ with all the edges sorted by their cost}
\begin{algorithmic}
\Procedure{MCP}{$G, s, t$}
	\State $visited[s] = \rm{True}$
	\State $G' =\rm{NULL} $
	\For {$e \in G$}
		\If{$visited[e.from] \&\& !visited[e.to]$}
			\State $bfs\_graph(e.to, G')$
		\Else
			\State $G'.add\_edge(e)$
		\EndIf
		\If{$visited[t]$}
			\State \Return $e.weight$
		\EndIf
	\EndFor
\EndProcedure
\Procedure{bfs\_graph}{$s, G$}
	\State $visited[s] = \rm{True}$
	\State $queue.push(s)$
	\While {!queue.empty()}
		\State $top = queue.top()$
		\State $queue.pop()$
		\For{$e \in G[top]$}
			\If {$!visited[e.to]$}
				\State $visited[e.to] = \rm{True}$
				\State $q.push(e.to)$
			\EndIf
		\EndFor
	\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}
\end{proof}

\begin{exercise}
   Give an algorithm for MCP of running time $O(m \log \log m)$. \textbf{Hint:} Using the median-of-medians algorithm,
   you can determine an edge $e$ such that at most $m/2$ edges are cheaper than $e$ and at most $m/2$ edges are
   more expensive than $e$. Can you determine, in time $O(n+m)$, whether $c^* < c(e)$, $c^* = c(e)$, or $c^* > c(e)$?
   Iterate to shrink the set of possible
    values for $c^*$ to $m/4$, $m/8$, and so on.
\end{exercise}
\begin{proof}
	As is shown by the hint, during each iteration, we can shrink the
	set of possible values of $c^{*}$, i.e. 
	\[
E_1= \{e \mid c\left( e \right) \le M,e\in E'\}, 
		E_2 = \{e \mid c\left( e \right) > M, e\in E'\}
		\]
	We we can find a path in  $E_2$, then the lower bound $L$ of $c^{*}$ can 
	be updated to $M$. Since if $c^{*}>L$, we must have a 
	path $e$ with all the edges larger then $L$.

	Otherwise, the upper bound $U$ will be $M$ as there is no such path with 
	all edges larger than $M$. However, if we take iterations until 
	$L = U$, we will have $O\left( m\log m  \right)  $ running time. So we only do 
	$ \log(s\left( m \right) )$ 
	iterations. Here $s$ is a place holder to decide later

	Consider the following algorithm
	\begin{algorithm}[H]
		\caption{Solve MCP in time $n\log\log n$ }
		\begin{algorithmic}
				\State $i=0, U = \infty, L = 0$
				\While {$i < \log s\left( m \right) $ }
				\State Determine the median of $\{e \mid e\in E',c\left( e \right) \le U\} $.
				\If $\left( V,E_2 \right) $ is $s$- $t$ connected 
				\State $E' \leftarrow E_2, L = M$,
				\Else 
				\State $U = M$
				\EndIf
				\State $i=i+1$
				\EndWhile	
				\State Number $t$ edges in set $\{e \in E' \mid c\left( e \right) \le U\} $ according to increasing order $e_1,e_2,\ldots.$
				\State Solve instance by \textbf{Algorithm 1} with the following 
				ordering, i.e. the place of $e$ in the sorted array 
				\[
						l\left( e \right) = \begin{cases}
								1, \quad c\left( e \right) \le L \\
								i, \quad  \exists i,e =e_{i} \\
								t, \quad c \left( e \right) > U
						\end{cases}
				.\] 
		\end{algorithmic}
\end{algorithm}
Now we prove this algotihm is $n\log \log n$, just notice that 
\[
		t = O\left( \frac{m}{s\left( m \right) } \right) 
.\] 
Since every iteration we make the set $\{ e  \mid  e\in E', c\left( e \right) 
< U\} $ shrinks to $\frac{1}{2}$. That is 
the size $t = \lvert  E'\rvert \le \frac{m}{2^{\log s\left( m \right) }}$. 

Thus the running time is 
\[
\log\left( s\left( m \right) \right)\cdot m + t \log t + t
\]
considering the sorting of the 
$t$ edges plus the running time of \textbf{Algorithm 1} ,
now we choose $s\left( m \right) = \log m $ to minimize the time which is 
\[
		m\left( \frac{\log m}{s} - \frac{\log s}{s} \right) 
.\] 
Hence 
\[
		T =O \left( \frac{m}{\log m} \log \left( \frac{m}{\log m } \right) \right) + 
		O \left( \log m \right) 
		= O\left( m\log\log m  \right) 
.\] 
\end{proof}


\begin{exercise}
   Give an algorithm for MCP that runs in time $O(m \log \log \log m)$? How about $O(m \log \log \log \log m)$? How far can you get?
\end{exercise}
\begin{proof}
		We can have a better algorithm runs in $O\left( m \log\log\log m \right) $, 
		since there is no need to sort the $t$ edges in $O\left( t\log t \right) $. 
		We can just use a 
		complex priority queue\footnote{ only supoort \texttt{insert} and \texttt{extract\_max} actions, check this paper for detail: \texttt{On RAM priority queues}. }
		with running time of insertion $O\left( \log\log n \right) $ 
		to maintain $\{ e  \mid  e\in E', c\left( e \right) \le U \} $.
		
		It is worth mentioning that the above algorithm only works in 
		\textbf{RAM model of computing}, which means that the $c\left( e \right) $ 
		only occupies one word of space in our computer.
		More details refer to wiki of \textbf{integer sorting}. 

		But can we do better? I think it depends on how fast the sorting or 
		priority queue could run, and currently it seems that there 
		is no better result i.e. an $O\left( n\log\log\log n \right) $ sorting 
		algorithm.

		To sum up, if we use \textbf{RAM model of computing}, we can  
		exactly
		reach $O\left( m\log\log\log m \right) $ running time, but if 
		$c\left( e \right) ,\forall e$ could be arbitrarily large, for example 
		$\Theta\left( n^2 \right) $, we can not improve the result.
\end{proof}

\end{document}
