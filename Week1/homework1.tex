\documentclass[UTF8]{ctexart} 
\usepackage{amsmath} 
\usepackage{graphicx}
\usepackage{pythonhighlight}
\usepackage{indentfirst}


\begin{document} 

\title{Homework 1}
\author{Ji Jiabao}
\maketitle

\subsection*{Exer.1:}
First, we know $n > k$ since $a > b$. To get r, $r = a \% b, (0 \leq r < b)$,
so the bits of $r$, we write it as $b_r$. $b_r < k$.\\
Remind the procedure of brute-force algorithm of $a \% b$, in each iteration,
$n$ decreases(since we can drop the higher bits). In the final iteration, $n < k$,
also this $n$ is exactly $b_r$, so we don't need to do the iteration $n$ times,
but only $n - k$ times. And each iteration costs $n$ subtraction operation, which is an integer operation,
in all we do no more than $n(n - k)$ times of basic operations.

\subsection*{Exer.2:}
We prove it by induction on bits of $a, b$, marked as $n, m$, and for $r$ in each iteration,
we have $n$\\
suppose it takes $k$ times of iteration. 

\begin{equation*}
    T   = \sum_{i = 1}^k T_i
        = \sum_{i = 1}^k n_i * m_i
        < \sum_{i = 1}^k n_i *(n_i - n_{i - 1})
\end{equation*}

\newpage

\subsection*{Exer.3:}
recursive code: 
\begin{python}
def recursiveCompute(n, k):
    if (n <= k or k == 0):
        return 1
    else:
        return recursiveCompute(n - 1, k - 1) + recursiveCompute(n - 1, k)
\end{python}

Like recursive algorithm for computing Fib(n), we can get a recursive tree, 
which has $ \binom n k$ leaves and $ (2 \binom n k - 1) $nodes in all.We can prove it by induction.
\\
\hspace*{1em} Firstly, prove it for a fixed n, to do that, we use an induction. 
And suppose the equation is true for all $m < n$(base $n = 1$ is trivial).\\
$Base: k = 0:$\\
\hspace*{1em} Obviously, the recursive tree only has 1 node, which satisfies the equation.\\
$Induction:$\\
\hspace*{1em} To compute $\binom n {k+1} $, we will add a node for $\binom n {k+1}$ as the new root,
and two sub recursive tree for computing $\binom {n - 1} {k}, \binom {n - 1}{k + 1}$, 
whose nodes size is known by induction hypothesis.\\
\hspace*{1em} The new tree has $\binom {n-1} {k} + \binom{n - 1} {k + 1} = \binom{n}{k + 1}$ leaves,
and $(2\binom{n - 1}{k} - 1)+ (2\binom{n - 1}{k + 1} -1) + 1= 2\binom n {k + 1} - 1 $ nodes.

Similar to the induction above, we can tell for any $n, k$, the result holds.
For the running time analysis, each node in the tree needs to do an addition,
so it's $\Omega (2 \binom n k - 1)$, if we consider the cost of addition at each node $log {n}{k}$, we get
$O((2 \binom n k - 1)log(\binom n k))$.\\
\hspace*{1em} To sum up, the algorithm is $\Omega(\binom n k)$ and $O(\binom n k log(\binom n k))$\\
\hspace*{1em} It's not a good algorithm, since the time complexity is very high, and it does a lot of 
redundant addition.

\newpage

\subsection*{Exer.4:}
code:
\begin{python}
def dpCompute(n, k):
    a = [[0 for x in range(k + 1)] for y in range(n + 1)] 
    for i in range (n + 1):
        a[i][0] = 1
        if (i <= n - k):
            for j in range (1, min(i, k) + 1):
                a[i][j] = a[i - 1][j - 1] + a[i - 1][j]
        else:
            for j in range(i - (n - k), min(i, k) + 1):
                a[i][j] = a[i - 1][j - 1] + a[i - 1][j]
    return a[n][k]
\end{python}
The algorithm needs to do $n$ iterations, for iterations $i <= n - k$, 
we should do $min(i, k)$ additions, and for $i > n - k$, we should do $min(i, k) - i - (n - k)$ additions
(since there is no node of $\binom i j (i > n - k, j < i - (n - k))$ in the recursive tree)
In all, we need to compute
$$
    \sum_{i = 1}^{n - k} \sum_{j = 1}^{min(i, k)} + 
    \sum_{i = n - k + 1}^{n + 1}\sum_{j = i - (n - k)}^{min(i, k) + 1}
    = n (n - k)
$$
additions. \\
\hspace*{1em} Consider the cost of each addition, the algorithm is $\Omega(n(n - k))$ and $O(n(n - k) log \binom n k)$.
It's much more efficcient than the recursive algorithm. I think it's efficcient.


\subsection*{Exer.5:}
The running time is similar to Exer.4, but since we only needs to know whether the result modula 2 is 1 or 0,
we don't need to compute addition at each node but only a bool compute. \\
\hspace*{1em} So the dynamic algorithm is $\Theta (n(n - k))$.\\
\hspace*{1em} To this question specifically,not efficcient, 
we don't have to compute the value of $\binom n k$ at all.\\
Below is the python code.
\newpage
\begin{python}
def hasNtwoFactor(asking):
    res = 0
    while (asking % 2 == 0):
        res += 1
        asking = asking / 2
    return res

def isEvenOrOdd(n, k):
    numerator = 0
    dominator = 0
    for i in range(1, n + 1):
        numerator += hasNtwoFactor(i)
    for i in range(1, k + 1):
        dominator += hasNtwoFactor(i)
    for i in range(1, n - k + 1):
        dominator += hasNtwoFactor(i)
    if (numerator - dominator > 0):
        return bool(1)
    else:
        return bool(0)
\end{python}
it's an $\Theta(n log(n))$ algorithm, faster than dpCompute.


\end{document}